/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker;import java.util.Hashtable;import org.alberta.poker.util.Reporter;/** * This is a standard dealer class for managing a Holdem game. * * Does not (yet) handle 'all-In' situations * * @author Aaron Davidson * @version 1.1.2 */public class Dealer implements Runnable {    private HandEvaluator he = new HandEvaluator();    private boolean THREADED = false;    protected Reporter r;    protected GameInfo gInfo;    protected Deck gDeck;    protected Hashtable bettors;    protected Hand[] holes;    private int gAction, gCode;    private int toAct;    /**     * Constructor.     */    public Dealer() {        init();        gDeck = new Deck();    }    /**     * Constructor w/ random seed.     *     * @param seed the random seed to use for deck shuffling     */    public Dealer(int seed) {        init();        gDeck = new Deck(seed);    }    public void setThreaded(boolean th) {        THREADED = th;        he.setThreadSafe(th);    }    public void setSeed(int seed) {        gDeck = new Deck(seed);    }    private void init() {        holes = new Hand[Holdem.MAX_PLAYERS];        bettors = new Hashtable(Holdem.MAX_PLAYERS);        gInfo = new GameInfo();        r = gInfo.getReporter();        setThreaded(THREADED);    }    /**     * Add a player to the next game (if there is room)     *     * @param name the name of the player to add     * @param b	the actual player which will make decisions     * @return	true if player is added, flase if not     */    public boolean addPlayer(String name, Player b) {        if (gInfo.getNumPlayers() == Holdem.MAX_PLAYERS - 1 || bettors.containsKey(name)) {            return false;        }        bettors.put(name, b);        return gInfo.addPlayer(name, gInfo.LOG_DIR + name.toLowerCase() + ".dat");    }    /**     * Add a player to the next game (if there is room)     *     * @param name the name of the player to add     * @param b	the actual player which will make decisions     * @return	true if player is added, flase if not     */    public boolean insertPlayer(String name, Player b, int pos) {        if (gInfo.getNumPlayers() == Holdem.MAX_PLAYERS - 1 || bettors.containsKey(name)) {            return false;        }        bettors.put(name, b);        return gInfo.insertPlayer(name, gInfo.LOG_DIR + name.toLowerCase() + ".dat", pos);    }    /**     * Remove a player from the next game.     *     * @param name the name of the player     * @return true if removed, false if not     */    public boolean removePlayer(String name) {        if (gInfo.getNumPlayers() == 0 || !bettors.containsKey(name)) {            return false;        }        bettors.remove(name);        return gInfo.removePlayer(name);    }    /**     * Remove all players from the next game.     */    public void removeAllPlayers() {        bettors.clear();        gInfo.removeAllPlayers();    }    /**     * Obtain the game info for the current game.     */    public GameInfo getGameInfo() {        return gInfo;    }    /**     * Check if a player with a given name is already in the game.     *     * @param name the player name to check     * @return true if the player is in the game     */    public boolean inGame(String name) {        return bettors.containsKey(name);    }    // list players & bankrolls    public void printTable() {        println("");        println("\n--- NEW GAME --- " + gInfo.getID() + " ---");        for (int i = 0; i < gInfo.getNumPlayers(); i++) {            println((i == gInfo.getButton() ? ("B> ") : (" > ")) + pad(gInfo.getPlayerName(i), 14) + " " + gInfo.getPlayerInfo(i).getBankRoll());        }        println("-----------------------");    }    public void dealCards() {        gDeck.shuffle();        gDeck.shuffle();        gDeck.shuffle();        // deal cards to each player          for (int i = 0; i < gInfo.getNumPlayers(); i++) {            Hand h = new Hand();            h.addCard(gDeck.dealCard());            h.addCard(gDeck.dealCard());            holes[i] = h;            ((Player) bettors.get(gInfo.getPlayerName(i))).newGame(gInfo, h.getCard(1), h.getCard(2), i);        }    }    public Card nextBoardCard() {        return gDeck.dealCard();    }    /**     * Play one game of poker with the current set of players     */    public void playGame() {        // check if not enough players        if (gInfo.getNumPlayers() < 2) {            return;        }        int i;        gInfo.startNewGame();        printTable();        /*	println("");		println("--- NEW GAME --- " + gInfo.getID() + " ---");			for (i=0;i<gInfo.getNumPlayers();i++) 			println(" > " + pad(gInfo.getPlayerName(i), 14) + " $" + gInfo.getPlayerInfo(i).getBankRoll() );		// list players & bankrolls		println("-----------------------");*/        dealCards();        toAct = gInfo.getNumActivePlayers();        // start preflop betting round        updatePlayers(GameInfo.U_STAGE, Holdem.PREFLOP);        gInfo.advanceCurrentPlayer();        // small blind        gInfo.smallBlind();        updatePlayers(GameInfo.U_SBLIND, gInfo.getCurrentPlayerPosition());        println(gInfo.getCurrentPlayerName() + " blinds $" + (gInfo.getLowBet() / 2));        gInfo.advanceCurrentPlayer();        // big blind        gInfo.bigBlind();        updatePlayers(GameInfo.U_BBLIND, gInfo.getCurrentPlayerPosition());        println(gInfo.getCurrentPlayerName() + " blinds $" + gInfo.getLowBet());        gInfo.advanceCurrentPlayer();        if (betLoop()) {            return;        }        // flop        gInfo.flop(nextBoardCard(), nextBoardCard(), nextBoardCard());        println("************************************");        println(" FLOP: " + gInfo.getBoard().toString() + "          \t$" + gInfo.getPot());        println("************************************");        updatePlayers(GameInfo.U_STAGE, Holdem.FLOP);        if (betLoop()) {            return;        }        // turn	        gInfo.turn(nextBoardCard());        println("************************************");        println(" TURN: " + gInfo.getBoard().toString() + "       \t$" + gInfo.getPot());        println("************************************");        updatePlayers(GameInfo.U_STAGE, Holdem.TURN);        if (betLoop()) {            return;        }        // river        gInfo.river(nextBoardCard());        println("************************************");        println(" RIVR: " + gInfo.getBoard().toString() + "    \t$" + gInfo.getPot());        println("************************************");        updatePlayers(GameInfo.U_STAGE, Holdem.RIVER);        if (betLoop()) {            return;        }        showdown();        gInfo.gameOver();        updatePlayers(GameInfo.U_GAME_OVER, 0);        for (int j = 0; j < gInfo.getNumPlayers(); j++) {            gInfo.revealHand(j, holes[j].getCard(1), holes[j].getCard(2));        }        gInfo.logGame();    }    public int getToAct() {        return toAct;    }    protected boolean betLoop() {        toAct = gInfo.getNumActivePlayers();        //if (!gInfo.activePlayer(gInfo.getButton())) gInfo.advanceCurrentPlayer();        // betting loop        while (toAct > 0) {            switch (((Player) bettors.get(gInfo.getCurrentPlayerName())).action()) {                case Holdem.FOLD:                    toAct--;                    println(gInfo.getCurrentPlayerName() + " folds");                    boolean gameover = gInfo.fold();                    updatePlayers(GameInfo.U_FOLD, gInfo.getCurrentPlayerPosition());                    if (gameover) {                        gInfo.advanceCurrentPlayer();                        gInfo.getCurrentPlayerInfo().win(gInfo.getPot());                        gInfo.addWinner(gInfo.getCurrentPlayerName());                        println(gInfo.getCurrentPlayerName() + " wins $" + gInfo.getPot());                        gInfo.gameOver();                        updatePlayers(GameInfo.U_GAME_OVER, 0);                        for (int j = 0; j < gInfo.getNumPlayers(); j++) {                            gInfo.revealHand(j, holes[j].getCard(1), holes[j].getCard(2));                        }                        gInfo.logGame();                        return true;                    }                    break;                case Holdem.CALL:                    toAct--;                    doCall();                    break;                case Holdem.RAISE:                    // handle maximum raise error by calling instead                    if (gInfo.getNumRaises() >= Holdem.MAX_RAISES) {                        toAct--;                        doCall();                    } else {                        toAct = gInfo.getNumActivePlayers() - 1;                        doRaise();                    }                    break;                default:                    break;            }            gInfo.advanceCurrentPlayer();        }        toAct = gInfo.getNumActivePlayers();        return false;    }    private void doCall() {        int amnt = gInfo.call();        if (amnt == 0) {            println(gInfo.getCurrentPlayerName() + " checks");            updatePlayers(GameInfo.U_CHECK, gInfo.getCurrentPlayerPosition());        } else {            println(gInfo.getCurrentPlayerName() + " calls $" + amnt);            updatePlayers(GameInfo.U_CALL, gInfo.getCurrentPlayerPosition());        }    }    private void doRaise() {        if (gInfo.raise()) {            println(gInfo.getCurrentPlayerName() + " bets $" + gInfo.getBetSize());            updatePlayers(GameInfo.U_BET, gInfo.getCurrentPlayerPosition());        } else {            println(gInfo.getCurrentPlayerName() + " raises $" + gInfo.getBetSize());            updatePlayers(GameInfo.U_RAISE, gInfo.getCurrentPlayerPosition());        }    }    protected void showdown() {        int i, j;        int best, ties = 0;        j = best = gInfo.nextActivePlayer(-1);        for (i = 0; i < gInfo.getNumActivePlayers(); i++, j = gInfo.nextActivePlayer(j)) {            gInfo.revealHand(j, holes[j].getCard(1), holes[j].getCard(2));            println(gInfo.getPlayerName(j) + ": " + holes[j].toString());            updatePlayers(GameInfo.U_SHOWDOWN, j);            for (int k = 0; k < 5; k++) {                holes[j].addCard(gInfo.getBoardCard(k));            }            if (best != j) {                int v = he.compareHands(holes[j], holes[best]);                if (v == 1) {                    best = j;                    ties = 0;                } else if (v == 0) { // equally strong hands                    ties++;                }            }        }        if (ties == 0) {            gInfo.getPlayerInfo(best).win(gInfo.getPot());            gInfo.addWinner(gInfo.getPlayerName(best));            println(gInfo.getPlayerName(best) + " wins $" + gInfo.getPot() + " with " + he.nameHand(holes[best]));        } else {            // divide pot amongst winners            int excess = gInfo.getPot() - (ties + 1) * (gInfo.getPot() / (ties + 1));            j = gInfo.nextActivePlayer(gInfo.getButton());            for (i = 0; i < gInfo.getNumActivePlayers(); i++, j = gInfo.nextActivePlayer(j)) {                if (he.compareHands(holes[j], holes[best]) == 0) {                    int e = (excess-- > 0 ? 1 : 0);                    int ps = e + gInfo.getPot() / (ties + 1);                    gInfo.addWinner(gInfo.getPlayerName(j));                    gInfo.getPlayerInfo(j).win(ps);                    println(gInfo.getPlayerName(j) + " wins $" + ps + " with " + he.nameHand(holes[best]));                }            }        }        //println("High: " + he.nameHand(holes[best]));    }    public void run() {        String str = Thread.currentThread().getName();        ((Player) bettors.get(str)).update(gAction, gCode);    }    protected void updatePlayers(int action, int code) {        if (action == GameInfo.U_GAME_OVER || (!THREADED)) {            for (int i = 0; i < gInfo.getNumPlayers(); i++) {                ((Player) bettors.get(gInfo.getPlayerName(i))).update(action, code);            }        } else {            Thread[] t = new Thread[gInfo.getNumPlayers()];            gAction = action;            gCode = code;            for (int i = 0; i < gInfo.getNumPlayers(); i++) {                t[i] = new Thread(this, gInfo.getPlayerName(i));                t[i].start();            }            for (int i = 0; i < gInfo.getNumPlayers(); i++) {                try {                    t[i].join();                } catch (InterruptedException ie) {                }            }        }    }    protected void println(String s) {        r.report(s);    }    protected void print(String s) {        r.reportb(s);    }    public static String pad(String s, int size) {        if (s.length() < size) {            return pad(s + " ", size);        }        return s;    }}