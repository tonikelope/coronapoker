/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker;import org.alberta.poker.ai.Context;import org.alberta.poker.util.Preferences;import org.alberta.poker.util.Reporter;/** * Stores all of the information for a player during a poker game. Also contains * references to a player's past history of games. * * This class is a little messy from evolution, and has some ugly hooks for the * AI system. * * @author Aaron Davidson * @version 2.0.0 */public class PlayerInfo {    private String pName;  		// index name and id    private int bankRoll;		// player's money    private int amount_in = 0; 	// money spent this game    private String revHand;		// revealed hand    private GameInfo gInfo;			// game state information    private Preferences pPrefs = null;    private int last_amount_called; // last amount called    private double last_betstocall;    private Context gContext;    private int last_action;    private int lcode;    private int curIndex = 0; 	// index into current action    private String actions; 		// game action list    // flagged if player has voluntarily committed     // money to the pot during the current betting round    private boolean committed = false;    private double delta = 0;    private double winnings = 0;    private int num_games = 0;    /**     * Constructor.     *     * @param playerName the name of the player     * @param gi the game that the player is in     */    public PlayerInfo(String playerName, GameInfo gi) {        pName = playerName;        gInfo = gi;    }    /**     * Constructor.     *     * @param playerName the name of the player     * @param gi the game that the player is in     */    public PlayerInfo(String playerName, String fname, GameInfo gi) {        pName = playerName;        gInfo = gi;        if (fname != null) {            load(fname);        }    }    private void load(String fname) {        if (pPrefs == null) {            pPrefs = new Preferences(fname);        }        if (pPrefs.empty() || pPrefs.getPreference("BANKROLL") == null) {            delta = bankRoll = 0;            return;        }        num_games = pPrefs.getIntPreference("NUM_GAMES");        delta = bankRoll = pPrefs.getIntPreference("BANKROLL");        winnings = pPrefs.getDoublePreference("WINNINGS");    }    public void save() {        double gain = getNetGain();        winnings += gain;        // log winnings to history file if there is one specified        Reporter.log(winnings + "\n", gInfo.LOG_DIR + pName.toLowerCase() + ".win");        pPrefs.setPreference("NUM_GAMES", num_games);        pPrefs.setPreference("BANKROLL", bankRoll);        pPrefs.setPreference("WINNINGS", (double) winnings);        pPrefs.setPreference("NAME", pName);        pPrefs.savePreferences();    }    public double getNetGain() {        return (double) ((bankRoll - delta) / (double) gInfo.getLowBet());    }    public void setBankRoll(int br) {        bankRoll = br;    }    public int getBankRoll() {        return bankRoll;    }    /**     * Start a new game with this player     */    public void startNewGame() {        actions = new String();        revHand = new String("-");        amount_in = 0;        delta = (double) bankRoll;        last_amount_called = 0;        last_betstocall = 0;        committed = false;        last_action = -1;        lcode = -1;        num_games++;    }    /**     * obtain the player's name     *     * @return the name of this player     */    public String getName() {        return new String(pName);    }    /**     * Obtain a string representation of the player's actions. Ex: crc/rc/cf c =     * check/call, r = bet/raise, f = fold, / = end of betting     *     * @return String of actions     */    public String getActions() {        return new String(actions);    }    /**     * Have the player pay what it owes to the pot. Note: Called only by Holdem.     *     * @param owed The amount which the player should have in the pot (not     * necessarily what is owed)     * @return The amount which the player has paid to the pot to owe nothing     */    protected int pay(int owed) {        int amount = owed - amount_in;        amount_in = owed;        bankRoll -= amount;        return amount;    }    /**     * Determine if a player is All-In     *     * @return true if all in, false otherwise     */    public boolean allIn() {        return (bankRoll == 0);    }    /**     * The Player has folded     */    protected void fold() {        double bets = gInfo.getBetsToCall(gInfo.getPlayerPosition(pName));        logContext(Holdem.FOLD, bets);        last_betstocall = bets;        actions += 'f';        last_action = Holdem.FOLD;    }    /**     * The Player pays the small blind     */    protected void smallBlind() {        actions += 's';        last_amount_called = amount_in;    }    /**     * The player pays the big blind     */    protected void bigBlind() {        actions += 'B';        last_amount_called = amount_in;    }    /**     * The player calls     */    protected int call(int owed) {        int amount = owed - amount_in;        if (amount == 0) {            check();            return 0;        }        int bets = amount / gInfo.getBetSize();        //bets = (bets >= 2 ? 2 : bets);        logContext(Holdem.CALL, bets);        last_action = Holdem.CALL;        amount_in = owed;        bankRoll -= amount;        actions += 'c';        last_betstocall = bets;        last_amount_called = amount;        committed = true;        return amount;    }    /**     * The player bets     */    protected int bet(int owed) {        logContext(Holdem.BET, 0);        int amount = owed - amount_in;        amount_in = owed;        bankRoll -= amount;        last_action = Holdem.BET;        committed = true;        actions += 'b';        last_amount_called = amount;        last_betstocall = 0;        return amount;    }    /**     * The player checks     */    protected void check() {        logContext(Holdem.CHECK, 0);        last_action = Holdem.CHECK;        actions += 'k';        last_amount_called = 0;        last_betstocall = 0;    }    /**     * The player raises     */    protected int raise(int owed) {        int amount = owed - amount_in;        double betstocall = (amount / (double) gInfo.getBetSize()) - 1;        logContext(Holdem.RAISE, betstocall);        bankRoll -= amount;        amount_in = owed;        last_action = Holdem.RAISE;        last_betstocall = betstocall;        committed = true;        actions += 'r';        last_amount_called = amount;        return amount;    }    /**     * The betting round is over     */    protected void advanceStage() {        actions += '/';        committed = false;        last_amount_called = 0;        last_betstocall = 0;    }    /**     * Convert a character representing an action to an Action number.     *     * @param c the character to convert     * @return the action number     */    public int charToAction(char c) {        switch (c) {            case 'f':                return Holdem.FOLD;            case 'c':                return Holdem.CALL;            case 'r':                return Holdem.RAISE;            case 'b':                return Holdem.SMALL_BLIND;            case 'B':                return Holdem.BIG_BLIND;            default:                break;        }        return -1;    }    /**     * Obtain a specific action from the player's actions.     *     * @param stage The betting round at which the action too place     * @param step The nth action taken during that betting round     * @return	the specified action (-1 if position does not exist)     */    public int getAction(int stage, int step) {        int i, j;        for (i = 0, j = 0; j < stage; i++) {            if (i >= actions.length()) {                return -1;            }            if (actions.charAt(i) == '/') {                j++;            }        }        j = i + step;        if (j >= actions.length()) {            return -1;        }        for (i = i + 1; i <= j; i++) {            if (actions.charAt(i) == '/') {                return -1;            }        }        return charToAction(actions.charAt(j));    }    /**     * Obtain the last action made by the player     *     * @return the last action or -1 if no action has been made yet     */    public int getLastAction() {        if (actions.length() == 0) {            return -1;        }        if (actions.charAt(actions.length() - 1) == '/' && actions.length() > 1) {            return charToAction(actions.charAt(actions.length() - 2));        }        return charToAction(actions.charAt(actions.length() - 1));    }    /**     * Give the player some money     *     * @param amount the amount of money to give     */    public void win(int amount) {        bankRoll += amount;    }    /**     * Reveal the hole cards in a showdown     *     * @param c1 the first card     * @param c2 the second card     */    public void revealHand(Card c1, Card c2) {        revHand = c1.toString() + "-" + c2.toString();    }    /**     * Obtain the hand revealed by this player     *     * @return the player's hand, or null if unrevealed     */    public Hand getRevealedHand() {        if (revHand != null && !revHand.equals("-")) {            return new Hand(revHand);        } else {            return null;        }    }    /**     * Determine the amount a player must pay to stay in the game     *     * @param amount_needed the total amount the player should have in the pot     * @return the amount needed to stay in.     */    public int getAmountToCall(int amount_needed) {        return amount_needed - amount_in;    }    /**     * Test if a player has volunatrily committed yet in this round     *     * @return true if player is committed, false if not.     */    public boolean isCommitted() {        return committed;    }    /**     * Obtain the player's pot odds     *     * @return the pot odds.     */    public double potOdds() {        int am = getAmountToCall(gInfo.getBetAmount());        return (double) am / (double) (gInfo.getPot() + am);    }    /**     * Obtain the player's predicted future pot odds     *     * @return the predicted pot odds.     */    public double potOdds2() {        return (double) ((2 * gInfo.getBetSize()) / (gInfo.getPot() + 6 * gInfo.getBetSize()));    }    /**     * Get the amount called by this player during his last action     */    public int getLastAmountCalled() {        return last_amount_called;    }    /**     * Obtain the amount of bets the player had to call during their last     * action.     */    public double getLastBetsToCall() {        return last_betstocall;    }    /**     * Obtain the amount the player has put in the pot.     */    public int getAmountInPot() {        return amount_in;    }    /**     * Log a context file (used to train neural nets for opponent move     * precition, etc...)     */    private void logContext(int action, double bets) {        Context c = new Context(this, action, bets);        /*			double potodds = (double)bets / (double)((gInfo.getPot()/(double)gInfo.getBetSize()) + bets);			c.setActionContext(action, bets, committed, gInfo.getStage(), potodds, gInfo.getNumRaises());			c.setPlayerContext(gInfo.getNumPlayers(), gInfo.getNumActivePlayers(),								 gInfo.getUnacted(), gInfo.getPlayerPosition(pName), gInfo.getButton(), false);			c.setHistoryContext(last_action, (int)getLastBetsToCall(), betRatio());			c.setGameContext(gInfo.getPot(), gInfo.getBetSize(), gInfo.getID());			c.setBoardContext(gInfo.getBoard());         */        gContext = c;        lcode = getLastActionCode();    }    /**     * The bet ratio is the number of times a player bet divided by the number     * of chances they had to bet (a measure of agressiveness)     */    public double betRatio() {        int b = 0, t = 0;        String s = getActions();        for (int i = 0; i < s.length(); i++) {            if (s.charAt(i) != '/') {                t++;                if (s.charAt(i) == 'r') {                    b++;                }            }        }        return (double) b / (double) t;    }    /**     * The ratio of the money in the pot that belongs to the player     */    public double potRatio() {        return (double) amount_in / (double) gInfo.getPot();    }    /**     * A single integer code for the last action made     */    public int getLastActionCode() {        return Context.getLastActionCode(last_action, (int) getLastBetsToCall());    }    /**     * A single integer code for the last action made     */    public int lastAction() {        return last_action;    }    /**     * Get the context of the last action made by this player.     */    public Context getActionContext() {        return gContext;    }    /**     * Get the context of the last action made by this player.     */    public GameInfo getGameInfo() {        return gInfo;    }}