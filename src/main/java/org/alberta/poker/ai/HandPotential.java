/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker.ai;import org.alberta.poker.Card;import org.alberta.poker.Deck;import org.alberta.poker.Hand;import org.alberta.poker.HandEvaluator;import org.alberta.poker.ai.model.WeightTable;/** * <B>Hand Potential.</B><BR> * Hand Potential is the calculation of the probability that a hand that is * currently behind will be ahead as more board cards are dealt. Negative * Potential (NPOT) is the probability that given that we are currently ahead, * future cards will put is behind. * * Contains the Hand Potential Calculations as described in:<BR> * <CITE> * <I>Dealing with Imperfect Information in Poker.</I><BR> * Denis Papp, M.Sc. thesis, 1998. * </CITE> * As well as Darse Billings' crude potential function. * * * @author Aaron Davidson * @version 1.1.0 */public class HandPotential {    private static HandEvaluator he;    private Deck d = new Deck();    private final static int AHEAD = 0;    private final static int TIED = 1;    private final static int BEHIND = 2;    private final static int NUM_SUITS = 4;    private final static int NUM_RANKS = 13;    private final static int TWO = 0;    private final static int ACE = 12;    private double ppot = -1, npot = -1, nr = 0;    public HandPotential() {        he = new HandEvaluator();    }    /**     * obtain the PPot calculated during the last call to ppot.     *     * @return the last calculated ppot.     */    public double getLastPPot() {        return ppot;    }    /**     * obtain the PPot calculated during the last call to npot.     *     * @return the last calculated npot.     */    public double getLastNPot() {        return npot;    }    /**     * Calculate the PPot and NPot of a hand. (Papp 1998, 5.3)     *     * @param c1 the first hole card     * @param c2 the second hole card     * @param bd the board cards     * @param w the weight table to use     * @param full if true, a full 2-card look ahead will be done (slow)     * @return the ppot (also sets npot variable accessible with getLastNPot())     */    public double ppot(Card c1, Card c2, Hand bd, WeightTable w, boolean full) {        double[][] HP = new double[3][3]; // init to 0        double[] HPTotal = new double[3]; // init to 0        double wInc = 0;        int ourrank5, ourrank7, opprank;        int i, j, k, l, index;        Hand board = new Hand(bd);        Hand myHand = new Hand(board);        Hand opHand = new Hand(board);        boolean TwoCardLookAhead = (board.size() == 3 && full);        Card o1, o2;        int o1i, o2i;        int[] e = new int[4];        for (i = 0; i < 3; i++) {            HPTotal[i] = 0;            for (j = 0; j < 3; j++) {                HP[i][j] = 0;            }        }        if (myCache6 == null) {            myCache6 = new int[52];        }        if (myCache == null && TwoCardLookAhead == true) {            myCache = new int[52][51];        }        if (oppCache == null && TwoCardLookAhead == true) {            oppCache = new int[270725];        }        if (oppCache6 == null) {            oppCache6 = new int[22100];        }        for (i = 0; i < 52; i++) {            myCache6[i] = 0;            if (TwoCardLookAhead == true) {                for (j = 0; j < 51; j++) {                    myCache[i][j] = 0;                }            }        }        if (TwoCardLookAhead == true) {            for (i = 0; i < 22100; i++) {                oppCache6[i] = 0;                oppCache[i] = 0;            }            for (i = 22100; i < 270725; i++) {                oppCache[i] = 0;            }        } else {            for (i = 0; i < 22100; i++) {                oppCache6[i] = 0;            }        }        myHand.addCard(c1);        myHand.addCard(c2);        ourrank5 = he.rankHand(myHand);        // remove all known cards        d.reset();        d.extractCard(c1);        d.extractCard(c2);        d.extractHand(board);        // tally all possiblities        for (i = d.getTopCardIndex(); i < 52; i++) {            o1 = d.getCard(i);            o1i = o1.getIndex();            opHand.addCard(o1);            e[0] = o1i;            for (j = i + 1; j < 52; j++) {                o2 = d.getCard(j);                o2i = o2.getIndex();                opHand.addCard(o2);                e[1] = o2i;                opprank = he.rankHand(opHand);                if (ourrank5 > opprank) {                    index = AHEAD;                } else if (ourrank5 == opprank) {                    index = TIED;                } else {                    index = BEHIND;                }                wInc = w.getCell(o1i, o2i);                HPTotal[index] += wInc;                for (k = d.getTopCardIndex(); k < 52; k++) {                    if (k == i || k == j) {                        continue;                    }                    if (TwoCardLookAhead == true) {                        for (l = k + 1; l < 52; l++) {                            if (l == i || l == j) {                                continue;                            }                            ourrank7 = getCachedRank(d.getCard(k), d.getCard(l), myHand);                            e[0] = o1i;                            e[1] = o2i;                            e[2] = d.getCard(k).getIndex();                            e[3] = d.getCard(l).getIndex();                            opprank = getCachedRank(e, board);                            if (ourrank7 > opprank) {                                HP[index][AHEAD] += wInc;                            } else if (ourrank7 == opprank) {                                HP[index][TIED] += wInc;                            } else {                                HP[index][BEHIND] += wInc;                            }                        }                    } else { // 1 card look ahead                        ourrank7 = getCachedRank(d.getCard(k), myHand);                        opprank = getCachedRank(o1, o2, d.getCard(k), board);                        if (ourrank7 > opprank) {                            HP[index][AHEAD] += wInc;                        } else if (ourrank7 == opprank) {                            HP[index][TIED] += wInc;                        } else {                            HP[index][BEHIND] += wInc;                        }                    }                }                /* end of look ahead */                opHand.removeCard();            }            opHand.removeCard();        }        /* end of possible opponent hands */        int mult = (TwoCardLookAhead ? 990 : 45);        double den1 = (mult * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));        double den2 = (mult * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));        if (den1 > 0) {            ppot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED] / 2) + (HP[TIED][AHEAD] / 2)) / (double) den1;        } else {            ppot = 0;        }        if (den2 > 0) {            npot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED] / 2) + (HP[TIED][BEHIND] / 2)) / (double) den2;        } else {            npot = 0;        }        return ppot;    }    private int[][] myCache;    private int[] myCache6;    private int[] oppCache;    private int[] oppCache6;    private int getCachedRank(Card c, Hand h) {        int i = c.getIndex();        if (myCache6[i] > 0) {            return myCache6[i];        }        h.addCard(c);        myCache6[i] = he.rankHand(h);        h.removeCard();        return myCache6[i];    }    private int getCachedRank(Card c1, Card c2, Hand h) {        int i = c1.getIndex();        int j = c2.getIndex();        if (i < j) {            int t = i;            i = j;            j = t;        }        if (myCache[i][j] > 0) {            return myCache[i][j];        }        h.addCard(c1);        h.addCard(c2);        myCache[i][j] = he.rankHand7(h);        h.removeCard();        h.removeCard();        return myCache[i][j];    }    private int getCachedRank(Card c1, Card c2, Card c3, Hand h) {        int i = c1.getIndex();        int j = c2.getIndex();        int k = c3.getIndex();        if (i < k) {            int t = i;            i = k;            k = t;        }        if (j < k) {            int t = j;            j = k;            k = t;        }        if (i < j) {            int t = i;            i = j;            j = t;        }        int ind = k + choose(j, 2) + choose(i, 3);        int v = oppCache6[ind];        if (v > 0) {            return v;        }        h.addCard(i);        h.addCard(j);        h.addCard(k);        oppCache6[ind] = v = he.rankHand(h);        h.removeCard();        h.removeCard();        h.removeCard();        return v;    }    private int getCachedRank(int[] c, Hand h) {        // bubble sort :-p        boolean flag = true;        while (flag) {            flag = false;            if (c[0] < c[1]) {                swap(c, 0, 1);                flag = true;            }            if (c[1] < c[2]) {                swap(c, 1, 2);                flag = true;            }            if (c[2] < c[3]) {                swap(c, 2, 3);                flag = true;            }        }        int i = c[3] + choose(c[2], 2) + choose(c[1], 3) + choose(c[0], 4);        int v = oppCache[i];        if (v > 0) {            return v;        }        h.addCard(c[0]);        h.addCard(c[1]);        h.addCard(c[2]);        h.addCard(c[3]);        oppCache[i] = v = he.rankHand7(h);        h.removeCard();        h.removeCard();        h.removeCard();        h.removeCard();        return v;    }    private int choose(int n, int r) {        if (r == 1) {            return n;        } else {            return ((n - (r - 1)) * choose(n, r - 1)) / r;        }    }    private void swap(int[] c, int i, int j) {        int t = c[i];        c[i] = c[j];        c[j] = t;    }    /**     * A crude but fast approximation of PPOT.     *     * @param c1 the first hole card     * @param c2 the second hole card     * @param board the board cards     */    public static double CrudePotential1(Card c1, Card c2, Hand board) {        Hand h = new Hand();        double outs = 0;        int i;        int top_r = TWO;        int rk, c, s;        int board_pair = -1;        int board_cards = board.size();        int[] num_suit = new int[NUM_SUITS];        int[] present = new int[NUM_RANKS];        h.addCard(c1);        h.addCard(c2);        for (i = 0; i < board.size(); i++) {            h.addCard(board.getCard(i + 1));        }        for (i = 2; i < h.size(); i++) {            rk = h.getCard(i + 1).getRank();            if (rk > top_r) {                top_r = rk;            }            present[rk]++;            if (present[rk] > 1) {                board_pair = rk;            }            num_suit[h.getCard(i + 1).getSuit()]++;        }        // - don't care about overpair        if (h.getCard(1).getRank() != h.getCard(2).getRank()) {            for (i = 0; i < 2; i++) {                int ni = ((i == 0) ? 1 : 0);                rk = h.getCard(i + 1).getRank();                if (rk > top_r) {                    outs += 0.9 * (NUM_SUITS - 1);                } else if (top_r > h.getCard(ni + 1).getRank() && top_r > rk && present[h.getCard(ni + 1).getRank()] > 0 && present[rk] == 0) {                    outs += 0.95 * (NUM_SUITS - 1);                } else if (rk < top_r && present[rk] == 0) {                    outs += 0.6 * (NUM_SUITS - 1);                } else if (present[rk] == 1 && board_pair < rk) {                    outs += 0.95 * (NUM_SUITS - 1 - present[rk]);                } else if (present[rk] == 2 && board_pair == rk) {                    outs += 0.95 * (NUM_SUITS - 1) * (board_cards - 2);                }            }        } else {            if (present[h.getCard(1).getRank()] != 0) {                if (board_pair == 0) {                    outs += 0.9 * (NUM_SUITS - 1) * (board_cards - 1);                }            } else {                outs += 0.99 * (NUM_SUITS - 2);                if (top_r < h.getCard(1).getRank() && board_pair == 0) {                    outs += 0.25 * (NUM_SUITS - 1) * board_cards;                }            }        }        int[] num_suit_hole = new int[]{0, 0, 0, 0};        int[] rank_suit_hole = new int[NUM_SUITS];        for (i = 0; i < 2; i++) {            num_suit_hole[h.getCard(i + 1).getSuit()]++;            rank_suit_hole[h.getCard(i + 1).getSuit()] = h.getCard(i + 1).getRank();        }        for (s = 0; s < NUM_SUITS; s++) {            if (num_suit[s] + num_suit_hole[s] == 4) {                if (num_suit_hole[s] == 1) {                    outs += (0.5 + 0.5 * rank_suit_hole[s] / NUM_RANKS) * (NUM_RANKS - 4);                } else if (num_suit_hole[s] == 2) {                    outs += 1.0 * (NUM_RANKS - 4);                }            }        }        // + id 4str, count hole        int gap0_straight = 0;        int gap0_hole = 0;        int gap1_straight = 0;        int gap1_hole = 0;        int r1 = h.getCard(1).getRank(), r2 = h.getCard(2).getRank();        if (present[ACE] != 0) {            gap0_straight++;        } else if (r1 == ACE || r2 == ACE) {            gap0_straight++;            gap0_hole++;        } else {            gap1_straight = 1;        }        for (rk = 0; rk < NUM_RANKS; rk++) {            if (present[rk] != 0) {                gap0_straight++;                gap1_straight++;            } else if (r1 == rk || r2 == rk) {                gap0_straight++;                gap1_straight++;                gap0_hole++;                gap1_hole++;            } else {                if (gap1_straight >= 5) {                    if (gap1_hole == 0) ; else if (gap1_hole == 1) {                        outs += 0.7 * NUM_SUITS;                    } else {                        outs += 1.0 * NUM_SUITS;                    }                }                // move gap0 to gap1                if (rk == ACE) {                    gap1_straight = gap0_straight;                    gap1_hole = gap0_hole;                } else {                    gap1_straight = gap0_straight + 1;                    gap1_hole = gap0_hole;                }                // reset gap0                gap0_straight = 0;                gap0_hole = 0;            }        }        // TERMINATE        if (gap1_straight >= 5) {            if (gap1_hole == 0); else if (gap1_hole == 1) {                outs += 0.7 * NUM_SUITS;            } else {                outs += 1. * NUM_SUITS;            }        }        return (double) outs / (double) (50 - h.size());    }    /**     * Calculate the raw (unweighted) PPot and NPot of a hand. (Papp 1998, 5.3)     *     * @param c1 the first hole card     * @param c2 the second hole card     * @param bd the board cards     * @param full if true, a full 2-card look ahead will be done (slow)     * @return the ppot (also sets npot variable accessible with getLastNPot())     */    public double ppot_raw(Card c1, Card c2, Hand bd, boolean full) {        double[][] HP = new double[3][3];        double[] HPTotal = new double[3];        int ourrank7, opprank;        int i, j, k, l, index;        Hand board = new Hand(bd);        boolean TwoCardLookAhead = (board.size() == 3 && full);        Card o1, o2;        int ourrank5 = he.rankHand(c1, c2, bd);        // remove all known cards        d.reset();        d.extractCard(c1);        d.extractCard(c2);        d.extractHand(board);        // pick first opponent card        for (i = d.getTopCardIndex(); i < 52; i++) {            o1 = d.getCard(i);            // pick second opponent card            for (j = i + 1; j < 52; j++) {                o2 = d.getCard(j);                opprank = he.rankHand(o1, o2, bd);                if (ourrank5 > opprank) {                    index = AHEAD;                } else if (ourrank5 == opprank) {                    index = TIED;                } else {                    index = BEHIND;                }                HPTotal[index]++;                // tally all possiblities                for (k = d.getTopCardIndex(); k < 52; k++) {                    if (i == k || j == k) {                        continue;                    }                    board.addCard(d.getCard(k));                    if (TwoCardLookAhead) {                        for (l = k + 1; l < 52; l++) {                            if (i == l || j == l) {                                continue;                            }                            board.addCard(d.getCard(l));                            ourrank7 = he.rankHand(c1, c2, board);                            opprank = he.rankHand(o1, o2, board);                            if (ourrank7 > opprank) {                                HP[index][AHEAD]++;                            } else if (ourrank7 == opprank) {                                HP[index][TIED]++;                            } else {                                HP[index][BEHIND]++;                            }                            board.removeCard();                        }                    } else {                        ourrank7 = he.rankHand(c1, c2, board);                        opprank = he.rankHand(o1, o2, board);                        if (ourrank7 > opprank) {                            HP[index][AHEAD]++;                        } else if (ourrank7 == opprank) {                            HP[index][TIED]++;                        } else {                            HP[index][BEHIND]++;                        }                    }                    board.removeCard();                }            }        }        /* end of possible opponent hands */        int mult = (TwoCardLookAhead ? 990 : 45);        double den1 = (mult * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));        double den2 = (mult * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));        if (den1 > 0) {            ppot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED] / 2) + (HP[TIED][AHEAD] / 2)) / (double) den1;        } else {            ppot = 0;        }        if (den2 > 0) {            npot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED] / 2) + (HP[TIED][BEHIND] / 2)) / (double) den2;        } else {            npot = 0;        }        /*	System.out.println("AHEAD ==> AHEAD = " + HP[AHEAD][AHEAD]);		System.out.println("AHEAD ==> TIED = " + HP[AHEAD][TIED]);		System.out.println("AHEAD ==> BEHIND = " + HP[AHEAD][BEHIND]);		System.out.println("TOTAL AHEAD = " + HPTotal[AHEAD] + "\n");		System.out.println("TIED ==> AHEAD = " + HP[TIED][AHEAD]);		System.out.println("TIED ==> TIED = " + HP[TIED][TIED]);		System.out.println("TIED ==> BEHIND = " + HP[TIED][BEHIND]);		System.out.println("TOTAL TIED = " + HPTotal[TIED] + "\n");		System.out.println("BEHIND ==> AHEAD = " + HP[BEHIND][AHEAD]);		System.out.println("BEHIND ==> TIED = " + HP[BEHIND][TIED]);		System.out.println("BEHIND ==> BEHIND = " + HP[BEHIND][BEHIND]);				System.out.println("TOTAL BEHIND = " + HPTotal[BEHIND] + "\n"); */        return ppot;    }    public double ppot_raw(String c1String, String c2String, String handString, boolean full) {        Card c1 = new Card(c1String);        Card c2 = new Card(c2String);        Hand bd = new Hand(handString);        double[][] HP = new double[3][3];        double[] HPTotal = new double[3];        int ourrank7, opprank;        int i, j, k, l, index;        Hand board = new Hand(bd);        boolean TwoCardLookAhead = (board.size() == 3 && full);        Card o1, o2;        int ourrank5 = he.rankHand(c1, c2, bd);        // remove all known cards        d.reset();        d.extractCard(c1);        d.extractCard(c2);        d.extractHand(board);        // pick first opponent card        for (i = d.getTopCardIndex(); i < 52; i++) {            o1 = d.getCard(i);            // pick second opponent card            for (j = i + 1; j < 52; j++) {                o2 = d.getCard(j);                opprank = he.rankHand(o1, o2, bd);                if (ourrank5 > opprank) {                    index = AHEAD;                } else if (ourrank5 == opprank) {                    index = TIED;                } else {                    index = BEHIND;                }                HPTotal[index]++;                // tally all possiblities                for (k = d.getTopCardIndex(); k < 52; k++) {                    if (i == k || j == k) {                        continue;                    }                    board.addCard(d.getCard(k));                    if (TwoCardLookAhead) {                        for (l = k + 1; l < 52; l++) {                            if (i == l || j == l) {                                continue;                            }                            board.addCard(d.getCard(l));                            ourrank7 = he.rankHand(c1, c2, board);                            opprank = he.rankHand(o1, o2, board);                            if (ourrank7 > opprank) {                                HP[index][AHEAD]++;                            } else if (ourrank7 == opprank) {                                HP[index][TIED]++;                            } else {                                HP[index][BEHIND]++;                            }                            board.removeCard();                        }                    } else {                        ourrank7 = he.rankHand(c1, c2, board);                        opprank = he.rankHand(o1, o2, board);                        if (ourrank7 > opprank) {                            HP[index][AHEAD]++;                        } else if (ourrank7 == opprank) {                            HP[index][TIED]++;                        } else {                            HP[index][BEHIND]++;                        }                    }                    board.removeCard();                }            }        }        /* end of possible opponent hands */        int mult = (TwoCardLookAhead ? 990 : 45);        double den1 = (mult * (HPTotal[BEHIND] + (HPTotal[TIED] / 2.0)));        double den2 = (mult * (HPTotal[AHEAD] + (HPTotal[TIED] / 2.0)));        if (den1 > 0) {            ppot = (HP[BEHIND][AHEAD] + (HP[BEHIND][TIED] / 2) + (HP[TIED][AHEAD] / 2)) / (double) den1;        } else {            ppot = 0;        }        if (den2 > 0) {            npot = (HP[AHEAD][BEHIND] + (HP[AHEAD][TIED] / 2) + (HP[TIED][BEHIND] / 2)) / (double) den2;        } else {            npot = 0;        }        /*	System.out.println("AHEAD ==> AHEAD = " + HP[AHEAD][AHEAD]);		System.out.println("AHEAD ==> TIED = " + HP[AHEAD][TIED]);		System.out.println("AHEAD ==> BEHIND = " + HP[AHEAD][BEHIND]);		System.out.println("TOTAL AHEAD = " + HPTotal[AHEAD] + "\n");		System.out.println("TIED ==> AHEAD = " + HP[TIED][AHEAD]);		System.out.println("TIED ==> TIED = " + HP[TIED][TIED]);		System.out.println("TIED ==> BEHIND = " + HP[TIED][BEHIND]);		System.out.println("TOTAL TIED = " + HPTotal[TIED] + "\n");		System.out.println("BEHIND ==> AHEAD = " + HP[BEHIND][AHEAD]);		System.out.println("BEHIND ==> TIED = " + HP[BEHIND][TIED]);		System.out.println("BEHIND ==> BEHIND = " + HP[BEHIND][BEHIND]);				System.out.println("TOTAL BEHIND = " + HPTotal[BEHIND] + "\n"); */        return ppot;    }}/*			if (TwoCardLookAhead==true) {				for (l=k+1;l<52;l++) {					board.addCard(d.getCard(l));					// roll out opponent cards...					for (i=d.getTopCardIndex();i<52;i++) {						if (i == k || i == l) continue;						// pick first opponent card						o1 = d.getCard(i);						for (j=i+1;j<52;j++) {							// pick second opponent card							o2 = d.getCard(j);							if (j == l || j == k) continue;							// calc before new cards							opprank = oranks[o1.getIndex()][o2.getIndex()];							if (ourrank5 > opprank) index = AHEAD;							else if (ourrank5 == opprank) index = TIED;							else index = BEHIND;							HPTotal[index]++;								// calc after new cards							ourrank7 = ranks[c1.getIndex()][c2.getIndex()];							opprank = ranks[o1.getIndex()][o2.getIndex()];							if (ourrank7 > opprank) HP[index][AHEAD]++;							else if (ourrank7 == opprank) HP[index][TIED]++;								else HP[index][BEHIND]++;						}					}					board.removeCard();				} 			} else { // 1 card look ahead		 */