/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker.ai;import org.alberta.poker.Holdem;import org.alberta.poker.util.Randomizer;/** * The Probabiltiy Triple Generator. Stores a probability distribution for three * parts for fold, call and raise. * * @author Aaron Davidson * @version 1.2.3 */public class ProbTriple {    private static Randomizer rnd = new Randomizer();    private double pf, pc, pr;    /**     * Default constructor. Values all zero.     */    public ProbTriple() {    }    /**     * Construct with the values given.     *     * @param f fold prob     * @param c call prob     * @param r raise prob     */    public ProbTriple(double f, double c, double r) {        pf = f;        pc = c;        pr = r;    }    /**     * Set the values given.     *     * @param f fold prob     * @param c call prob     * @param r raise prob     */    public void set(double f, double c, double r) {        pf = f;        pc = c;        pr = r;    }    public double getFold() {        return pf;    }    public double getCall() {        return pc;    }    public double getRaise() {        return pr;    }    /**     * Get the probability for an action     *     * @param action FOLD/CALL/RAISE     * @return the appropriate probability of that action     */    public double getValue(int action) {        switch (action) {            case Holdem.FOLD:                return (double) pf;            case Holdem.CALL:                return (double) pc;            case Holdem.RAISE:                return (double) pr;            default:                return 0;        }    }    /**     * Normalize the values in the triple to sum to 1.0     */    public void normalize() {        double t = (pf + pc + pr);        pf = pf / t;        pc = pc / t;        pr = pr / t;    }    public boolean valid() {        double t = pf + pc + pr;        return (t > 0.99999 && t < 1.00001);    }    /**     * Add the values of one triple into this one.     */    public void add(ProbTriple pt) {        this.pf = this.pf + pt.getFold();        this.pc = this.pc + pt.getCall();        this.pr = this.pr + pt.getRaise();    }    /**     * Add the values of one triple into this one.     */    public void dotProduct(ProbTriple pt) {        pf *= pt.pf;        pc *= pt.pc;        pr *= pt.pr;    }    /**     * Multiply all entries by a constant.     *     * @param val to multiply the values.     */    public void weight(double val) {        pf *= val;        pc *= val;        pr *= val;    }    public void setFold(double f) {        this.pf = f;    }    public void setCall(double c) {        this.pc = c;    }    public void setRaise(double r) {        this.pr = r;    }    /**     * Select an action from the triple distribution.     *     * @param spin a random value indexing into the triple.     * @param useMax take one of the maximum values in the triple.     */    public int select(double spin, boolean useMax) {        if (useMax) {            return selectMax(spin);        }        return select(spin);    }    /**     * Select an action from the triple using the given spinner.     *     * @param spin A random number between 0 and 1     */    public int select(double spin) {        if (spin < pf) {            return Holdem.FOLD;        } else if (spin < pf + pc) {            return Holdem.CALL;        } else {            return Holdem.RAISE;        }    }    /**     * Select the maximum value.     *     * @param spin A random number between 0 and 1     */    public int selectMax(double spin) {        if (pf > pc && pf > pr) {            return Holdem.FOLD;        }        if (pc > pf && pc > pr) {            return Holdem.CALL;        }        if (pr > pf && pr > pc) {            return Holdem.RAISE;        }        if (pr > pf && pr == pc) {            return (spin > 0.5 ? Holdem.CALL : Holdem.RAISE);        }        if (pc > pr && pc == pf) {            return (spin > 0.5 ? Holdem.FOLD : Holdem.CALL);        }        if (pr > pc && pr == pf) {            return (spin > 0.5 ? Holdem.FOLD : Holdem.RAISE);        }        return Holdem.CALL;    }    /**     * Select the maximum value.     */    public int selectMax() {        return selectMax(rnd.nextDouble());    }    /**     * Randomly select an action from the triple.     */    public int select() {        return select(rnd.nextDouble());    }    public String toString() {        return new String("{" + round((double) pf, 3) + ", " + round((double) pc, 3) + ", " + round((double) pr, 3) + "}");    }    private static double round(double f, int precision) {        double n = 1;        for (int i = 0; i < precision; i++) {            n *= 10;        }        return java.lang.Math.round(f * n) / n;    }}