/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker.util;import java.io.*;/** * This class stores a resizable array of bytes. Bytes can be read/written into * other variable formats. * * @author Aaron Davidson <davidson@cs.ualberta.ca> * @version 1.0.1 */public class ByteArray {    private byte[] v = null;    private int count = 0;    private int pos = 0;    public ByteArray() {        this(16);    }    /**     * Construct a ByteArray with the given starting capacity     *     * @param length the starting capacity of the ByteArray     */    public ByteArray(int length) {        v = new byte[length];    }    /**     * Construct a ByteArray from the bytes of a file.     *     * @param file the file to open and read the bytes from     */    public ByteArray(File file) throws IOException {        this(1024);        InputStream is = new BufferedInputStream(new FileInputStream(file));        int b = -1;        while ((b = is.read()) != -1) {            if (b == 13) {                b = 10;            }            append((byte) b);        }        is.close();    }    /**     * Write a serializable object to the ByteArray     *     * @param file the file to open and read the bytes from     */    public void appendObject(Serializable o) throws IOException {        ByteArrayOutputStream bs = new ByteArrayOutputStream();        ObjectOutputStream oos = new ObjectOutputStream(bs);        oos.writeObject(o);        byte[] bts = bs.toByteArray();        append((int) bts.length);        append(bts);        oos.close();        //System.out.println("Appended object " + bts.length + "  bytes");    }    /**     * Write a serializable object to the ByteArray     *     * @param file the file to open and read the bytes from     */    public Object readObject() throws IOException {        Object o = null;        int oSize = readInt();        byte[] bts = new byte[oSize];        for (int i = 0; i < oSize; i++) {            bts[i] = readByte();        }        //System.out.println("Reading object " + bts.length + "  bytes");        ByteArrayInputStream bs = new ByteArrayInputStream(bts);        try {            ObjectInputStream ois = new ObjectInputStream(bs);            o = ois.readObject();            ois.close();        } catch (ClassNotFoundException e) {            return null;        }        return o;    }    /**     * Construct a ByteArray from the bytes of a file.     *     * @param file the file to open and read the bytes from     */    public void appendFile(String fname) {        try {            RandomAccessFile f = new RandomAccessFile(fname, "r");            while (f.getFilePointer() < f.length()) {                byte[] bts = new byte[(int) f.length()];                f.readFully(bts);                append(bts);            }            f.close();        } catch (IOException e) {            e.printStackTrace();        }    }    /**     * Construct a ByteArray from an array of bytes     *     * @param b the bytes to place in the ByteArray.     *     */    public ByteArray(byte[] b) {        v = b;        count = b.length;    }    /**     * Erase and empty the contents of the ByteArray     */    public synchronized void clear() {        int len = v.length;        v = new byte[len];        count = 0;    }    /**     * @return the number of bytes.     */    public synchronized int size() {        return count;    }    /**     * Obtain the current capacity     *     * @return the current capacity     */    public synchronized int capacity() {        return v.length;    }    /**     * Append an array of bytes     */    public synchronized void append(byte[] b) {        int len = b.length;        int newcount = count + len;        if (newcount > v.length) {            expandCapacity(newcount);        }        System.arraycopy(b, 0, v, count, len);        count = newcount;    }    /**     * Append a ByteArray     */    public synchronized void append(ByteArray b) {        this.append(b.getBytes());    }    /**     * Append a byte     */    public synchronized void append(byte b) {        int newcount = count + 1;        if (newcount > v.length) {            expandCapacity(newcount);        }        v[count++] = b;    }    /**     * Append a String. Note: will be null-terminated.     */    public synchronized void append(String s) {        append(s.getBytes());        append((byte) 0);    }    /**     * Append a String. Note: C style string.     */    public synchronized void append(String s, int size) {        byte[] b = s.getBytes();        for (int i = 0; i < size; i++) {            if (i < b.length) {                append(b[i]);            } else {                append((byte) 0);            }        }    }    public synchronized void append(String s, boolean addSize) {        if (addSize) {            append(s.length());        }        append(s.getBytes());    }    /**     * Append an int (4 bytes)     */    public synchronized void append(int n) {        this.append(intToBytes(n));    }    /**     * Append a long     */    public synchronized void append(long n) {        this.append(longToBytes(n));    }    /**     * Append a double     */    public synchronized void append(double db) {        append((long) Double.doubleToLongBits(db));    }    public synchronized void write(int i, int n) {        byte[] b = intToBytes(n);        setByte(i, b[0]);        setByte(i + 1, b[1]);        setByte(i + 2, b[2]);        setByte(i + 3, b[3]);    }    /**     * Obtain the actual bytes stored.     *     * @return the array of bytes     */    public synchronized byte[] getBytes() {        byte[] r = new byte[count];        System.arraycopy(v, 0, r, 0, count);        return r;    }    /**     * Get the byte stored at a given index.     *     * @param i the position in the array to read a byte     */    public synchronized byte getByte(int i) {        if ((i < 0) || (i >= count)) {            throw new IndexOutOfBoundsException(Integer.toString(i));        }        return v[i];    }    public synchronized byte readByte() {        return getByte(pos++);    }    /**     * Set the byte at a given index     *     * @param i the index to set     * @param b the byte to write     */    public synchronized void setByte(int i, byte b) {        if ((i < 0) || (i >= count)) {            throw new IndexOutOfBoundsException(Integer.toString(i));        }        v[i] = b;    }    /**     * Read a string from the ByteArray. Reads until the end of the ByteArray,     * or until a null character is reached.     *     * @param i the index to start reading from     * @return the string read from the ByteArray     */    public synchronized String getString(int i) {        if (i < 0 || i >= count) {            return null;        }        ByteArray str = new ByteArray();        while (i < this.size() && this.getByte(i) != (byte) 0) {            str.append(this.getByte(i));            i++;        }        return new String(str.getBytes());    }    /**     * Read a string of a specific length from the ByteArray.     *     * @param i the index to start reading from     * @param l the length of the string     * @return the string read from the ByteArray     */    public synchronized String getString(int i, int l) {        if (i < 0 || i >= count) {            return null;        }        ByteArray str = new ByteArray();        while (i < i + l && i < count && this.getByte(i) != (byte) 0) {            str.append(this.getByte(i));            i++;        }        return new String(str.getBytes());    }    /**     * Read a string of a specific length from the ByteArray.     *     * @return the string read from the ByteArray     */    public synchronized String readPString() {        if (pos >= count) {            return null;        }        ByteArray str = new ByteArray();        int l = readInt();        for (int i = 0; i < l && pos < count; i++) {            str.append(this.readByte());        }        return new String(str.getBytes());    }    /**     * Read a null terminated string from the ByteArray.     *     * @return the string read from the ByteArray     */    public synchronized String readString() {        if (pos >= count) {            return null;        }        ByteArray str = new ByteArray();        byte b = this.readByte();        while (b != (byte) 0 && pos < count) {            str.append(b);            b = this.readByte();        }        return new String(str.getBytes());    }    public synchronized ByteArray getByteArray(int i, int l) {        if (l <= 0) {            return new ByteArray();        }        return new ByteArray(getBytes(i, l));    }    public synchronized ByteArray readByteArray(int l) {        if (l <= 0) {            return new ByteArray();        }        return new ByteArray(getBytes(pos, l));    }    public synchronized byte[] getBytes(int i, int size) {        if (size < 1 || i < 0 || i >= count) {            return null;        }        size = (i + size < count ? size : count - i);        byte[] b = new byte[size];        System.arraycopy(v, i, b, 0, size);        return b;    }    /**     * Read an int (4 bytes) from the ByteArray     *     * @param i the index to read from     * @param the int value stored at that location.     */    public synchronized int getInt(int i) {        if (i < 0 || size() < i + 4) {            return -1;        }        byte[] b = new byte[4];        b[0] = getByte(i);        b[1] = getByte(i + 1);        b[2] = getByte(i + 2);        b[3] = getByte(i + 3);        return bytesToInt(b);    }    /**     * Read an int (4 bytes) from the ByteArray     *     * @param i the index to read from     * @param the int value stored at that location.     */    public synchronized int readInt() {        int i = getInt(pos);        pos += 4;        return i;    }    /**     * Read an long (8 bytes) from the ByteArray     *     * @param i the index to read from     * @param the int value stored at that location.     */    public synchronized long getLong(int i) {        if (i < 0 || size() < i + 8) {            return -1;        }        byte[] b = new byte[8];        b[0] = getByte(i);        b[1] = getByte(i + 1);        b[2] = getByte(i + 2);        b[3] = getByte(i + 3);        b[4] = getByte(i + 4);        b[5] = getByte(i + 5);        b[6] = getByte(i + 6);        b[7] = getByte(i + 7);        return bytesToLong(b);    }    /**     * Read a long (8 bytes) from the ByteArray     *     * @param i the index to read from     * @param the int value stored at that location.     */    public synchronized long readLong() {        long l = getLong(pos);        pos += 8;        return l;    }    /**     * Read a double (8 bytes) from the ByteArray     *     * @param i the index to read from     * @param the int value stored at that location.     */    public synchronized double readDouble() {        long l = readLong();        return Double.longBitsToDouble(l);    }    /**     * Convert to a string representation     *     * @return a string made from the bytes in the array     */    public synchronized String toString() {        StringBuffer sb = new StringBuffer(count);        for (int i = 0; i < count; i++) {            sb.append((byte) v[i] + "_");        }        return sb.toString();    }    /**     * Ensure that the ByteArray has a minimal capacity. If the capacity does     * not exist, it will expand the capacity     *     * @param minimumCapacity the minimal capacity needed     */    public synchronized void ensureCapacity(int minimumCapacity) {        if (minimumCapacity > v.length) {            expandCapacity(minimumCapacity);        }    }    private void expandCapacity(int minimumCapacity) {        int newCapacity = (v.length + 1) * 2;        if (minimumCapacity > newCapacity) {            newCapacity = minimumCapacity;        }        byte newValue[] = new byte[newCapacity];        System.arraycopy(v, 0, newValue, 0, count);        v = newValue;    }    /**     * Set the size of the ByteArray     *     * @param newLength the new length     */    public synchronized void setSize(int newLength) {        if (newLength < 0) {            throw new IndexOutOfBoundsException(Integer.toString(newLength));        }        if (newLength > v.length) {            expandCapacity(newLength);        }        if (count < newLength) {            for (; count < newLength; count++) {                v[count] = 0;            }        } else {            count = newLength;        }    }    /**     * Write the contents of the ByteArray to a file.     *     * @param f the file to write to.     */    public void writeToFile(File f) throws IOException {        OutputStream os = new BufferedOutputStream(new FileOutputStream(f));        os.write(getBytes());        os.close();    }    public int getPos() {        return pos;    }    public void reset() {        pos = 0;    }    /**     * Converts a long to a 4-byte array.     *     */    public static byte[] intToBytes(int n) {        byte r[] = new byte[4];        r[3] = (byte) (n & 0x000000FF);        r[2] = (byte) ((n >> 8) & 0x000000FF);        r[1] = (byte) ((n >> 16) & 0x000000FF);        r[0] = (byte) ((n >> 24) & 0x000000FF);        return (r);    }    public static int bytesToInt(byte[] b) {        int r;        r = (int) ((b[3] < 0 ? 256 + b[3] : b[3]));        r += (int) ((b[2] < 0 ? 256 + b[2] : b[2]) << 8);        r += (int) ((b[1] < 0 ? 256 + b[1] : b[1]) << 16);        r += (int) ((b[0] < 0 ? 256 + b[0] : b[0]) << 24);        return (r);    }    /**     * Converts a long to a 8-byte array.     *     */    public static byte[] longToBytes(long n) {        byte r[] = new byte[8];        r[7] = (byte) (n & 0x000000FF);        r[6] = (byte) ((n >> 8) & 0x000000FF);        r[5] = (byte) ((n >> 16) & 0x000000FF);        r[4] = (byte) ((n >> 24) & 0x000000FF);        r[3] = (byte) ((n >> 32) & 0x000000FF);        r[2] = (byte) ((n >> 40) & 0x000000FF);        r[1] = (byte) ((n >> 48) & 0x000000FF);        r[0] = (byte) ((n >> 56) & 0x000000FF);        return (r);    }    public static long bytesToLong(byte[] b) {        int r;        r = (int) ((b[7] < 0 ? 256 + b[7] : b[7]));        r += (int) ((b[6] < 0 ? 256 + b[6] : b[6]) << 8);        r += (int) ((b[5] < 0 ? 256 + b[5] : b[5]) << 16);        r += (int) ((b[4] < 0 ? 256 + b[4] : b[4]) << 24);        r += (int) ((b[3] < 0 ? 256 + b[3] : b[3]) << 32);        r += (int) ((b[2] < 0 ? 256 + b[2] : b[2]) << 40);        r += (int) ((b[1] < 0 ? 256 + b[1] : b[1]) << 48);        r += (int) ((b[0] < 0 ? 256 + b[0] : b[0]) << 56);        return (r);    }}