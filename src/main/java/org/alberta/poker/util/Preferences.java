/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker.util;import java.io.*;import java.util.*;/** * Handles the storage and retrieval of program preferences Note. '=' is a * reserved character and may not be used to name preferences or within their * values. * * @author Aaron Davidson <davidson@cs.ualberta.ca> * @version 1.0.0 */public class Preferences {    String fName = null;    Hashtable prefs = new Hashtable();    /**     * Create a new set of Preferences from a given file.     *     * @param file the file name storing preferences     */    public Preferences(String file) {        fName = file;        loadPreferences(fName);    }    /**     * Load preferences fresh from disk     */    public Preferences(String prefstr, boolean notAfile) {        prefs = new Hashtable();        StringTokenizer stn = new StringTokenizer(prefstr, "\n");        while (stn.hasMoreTokens()) {            parsePrefLine(stn.nextToken());        }    }    private void parsePrefLine(String s) {        if (s.startsWith("#") || s.length() <= 2) {            return;        }        if (s.startsWith(">")) {            StringTokenizer st = new StringTokenizer(s, ">");            if (st.countTokens() == 1) {                String fn = st.nextToken();                File f = new File(fName);                String path = f.getParent();                if (path != null) {                    loadPreferences(path + "/" + fn);                } else {                    loadPreferences(fn);                }            }        } else {            StringTokenizer st = new StringTokenizer(s, "=");            if (st.countTokens() == 2) {                prefs.put(st.nextToken(), st.nextToken());            }        }    }    public boolean empty() {        return (prefs.size() == 0);    }    /**     * given a key preference name, obtain its value.     *     * @param name the name of the preference.     * @return the value of the preference     */    public synchronized String getPreference(String name) {        return (String) prefs.get(name);    }    /**     * given a key preference name, obtain its value as an int.     *     * @param name the name of the preference.     * @return the value of the preference     */    public synchronized int getIntPreference(String name) {        try {            String s = this.getPreference(name);            if (s != null) {                return Integer.decode(s).intValue();            } else {                return -1;            }        } catch (NullPointerException npe) {            return -1;        } catch (Exception e) {            return -1;        }    }    /**     * given a key preference name, obtain its value as an int.     *     * @param name the name of the preference.     * @return the value of the preference     */    public synchronized double getDoublePreference(String name) {        String str = this.getPreference(name);        if (str == null) {            return -1;        }        return (new Double(str)).doubleValue();    }    /**     * given a key preference name, obtain its value as a boolean value.     *     * @param name the name of the preference.     * @return the value of the preference     */    public synchronized boolean getBooleanPreference(String name) {        String str = this.getPreference(name);        if (str == null) {            return false;        }        return str.equals("true");    }    /**     * Set a preference.     *     * @param name name of the preference to set     * @param val value of the preference to set     */    public synchronized void setPreference(String name, String val) {        prefs.put(name, val);    }    /**     * Set a preference.     *     * @param name name of the preference to set     * @param val value of the preference to set     */    public synchronized void setPreference(String name, int val) {        prefs.put(name, Integer.toString(val));    }    /**     * Set a preference.     *     * @param name name of the preference to set     * @param val value of the preference to set     */    public synchronized void setPreference(String name, boolean val) {        prefs.put(name, (new Boolean(val)).toString());    }    /**     * Set a preference.     *     * @param name name of the preference to set     * @param val value of the preference to set     */    public synchronized void setPreference(String name, double val) {        prefs.put(name, (new Double(val)).toString());    }    /**     * Flush current preferences to disk.     */    public synchronized void savePreferences() {        try {            RandomAccessFile f = new RandomAccessFile(fName, "rw");            Enumeration e = prefs.keys();            while (e.hasMoreElements()) {                String k = (String) e.nextElement();                String s = k + "=" + (String) prefs.get(k) + "\n";                f.writeBytes(s);            }            while (f.getFilePointer() < f.length()) {                f.write('\n');            }            f.close();        } catch (IOException e) {            e.printStackTrace();        }    }    public String toString() {        StringBuffer sb = new StringBuffer();        Enumeration e = prefs.keys();        while (e.hasMoreElements()) {            String k = (String) e.nextElement();            sb.append(k);            sb.append("=");            sb.append((String) prefs.get(k));            sb.append("\n");        }        return sb.toString();    }    /**     * Load preferences fresh from disk     */    public synchronized void loadPreferences(String fname) {        //System.out.println("load " + fname);        try {            RandomAccessFile f = new RandomAccessFile(fname, "r");            StringTokenizer st;            while (f.getFilePointer() < f.length()) {                String s = f.readLine();                parsePrefLine(s);            }            f.close();        } catch (FileNotFoundException fnf) {            //	System.err.println("FILE NOT FOUND: " + fname);        } catch (IOException e) {            //	e.printStackTrace();        }    }    /**     * convert a string so that it fits all on one line (required for a valid     * preference string)     */    public static String munkString(String s) {        StringBuffer sb = new StringBuffer();        for (int i = 0; i < s.length(); i++) {            char c = s.charAt(i);            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')                    || (c >= '0' && c <= '9') || (c == '.') || (c == '-')) {                sb.append(c);            } else {                sb.append('{');                sb.append(Integer.toString((int) c));                sb.append('}');            }        }        return sb.toString();    }    /**     * Take a munked-up string and fix it.     */    public static String unmunkString(String s) {        StringBuffer sb = new StringBuffer();        for (int i = 0; i < s.length(); i++) {            char c = s.charAt(i);            if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z')                    || (c >= '0' && c <= '9') || (c == '.') || (c == '-')) {                sb.append(c);            } else if (c == '{') {                StringBuffer cb = new StringBuffer();                while (c != '}') {                    c = s.charAt(++i);                    if (c != '}') {                        cb.append(c);                    }                }                c = (char) (Integer.decode(cb.toString()).intValue());                sb.append(c);            }        }        return sb.toString();    }}