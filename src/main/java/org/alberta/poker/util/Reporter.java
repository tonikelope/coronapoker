/** ************************************************************************* * Copyright (c) 2000: * University of Alberta, * Deptartment of Computing Science * Computer Poker Research Group * * See "Liscence.txt" ************************************************************************** */package org.alberta.poker.util;import java.io.*;import java.util.*;/** * Handles reporting messages to stdout or stderr, and logging messages to * files. Defaults to printing output to stderr. * * @author Aaron Davidson * @version 1.3.5 */public class Reporter {    private boolean console = true;    private Vector listeners = new Vector();    private boolean active = true;    private boolean logOn;    private boolean debug = false;    private String logfile;    private volatile RandomAccessFile lf;    private static BufferedReader reader;    private static Reporter gRep = null;    public static synchronized Reporter getReporter() {        if (gRep == null) {            gRep = new Reporter();        }        return gRep;    }    public Reporter() {        // assumes reporter has already been statically initialized    }    public Reporter(String logfile) {        setLogFile(logfile);    }    public synchronized void setLogFile(String logfile) {        //System.out.println("SETTING REPORTS TO: " + logfile);        logOn = (logfile != null);        this.logfile = logfile;        try {            if (lf != null) {                lf.close();            }            if (logOn) {                lf = new RandomAccessFile(logfile, "rw");                lf.seek(lf.length());            }        } catch (IOException ie) {            ie.printStackTrace();        }    }    static {        reader = new BufferedReader(new InputStreamReader(System.in));    }    public void setDebug(boolean on) {        debug = on;    }    public void setActive(boolean t) {        active = t;    }    public void debug(String s) {        if (debug) {            report(s);        }    }    public void debugb(String s) {        if (debug) {            reportb(s);        }    }    public void addReportListener(ReportListener rl) {        listeners.addElement(rl);    }    public void removeReportListener(ReportListener rl) {        listeners.removeElement(rl);    }    private void callListeners(String s) {        for (int i = 0; i < listeners.size(); i++) {            ((ReportListener) listeners.elementAt(i)).reportMessage(s);        }    }    /**     * Non-negative value indicating priority threshold for reporting messages.     */    public int level = 0;    /**     * disable the output to console     */    public void consoleOff() {        console = false;    }    /**     * Set the output to console     */    public void consoleOn() {        console = true;    }    /**     * Print a message to the current output stream.     *     * @param s the string to print.     */    public synchronized void println(String s) {        report(s);    }    /**     * Print a message to the current output stream. Does not print a line feed     * at the end of the string.     *     * @param s the string to print.     */    public synchronized void print(String s) {        reportb(s);    }    /**     * Print a message to the current output stream.     *     * @param s the string to print.     */    public synchronized void report(String s) {        if (active) {            if (console) {                System.err.println(s);            }            if (logOn) {                appendLog(s + "\n");            }            callListeners(s + "\n");        }    }    /**     * Print a message to the current output stream. Does not print a line feed     * at the end of the string.     *     * @param s the string to print.     */    public synchronized void reportb(String s) {        if (active) {            if (console) {                System.err.print(s);            }            if (logOn) {                appendLog(s);            }            callListeners(s);        }    }    /**     * Print a message to the current output stream if the priority is high     * enough. Note: 0 is the highest priority. Larger numbers are of lower     * priority.     *     * @param s the string to print.     * @param priority the priority of this message     */    public synchronized void report(String s, int priority) {        if (active) {            if (priority > level) {                return;            }            if (console) {                System.err.println(s);            }            if (logOn) {                appendLog(s + "\n");            }            callListeners(s);        }    }    /**     * Logs a message to a file.     *     * @param s the message to log.     * @param file the name of the file to log to.     */    public synchronized static void log(String s, String file) {        try {            RandomAccessFile f = new RandomAccessFile(file, "rw");            f.seek(f.length());            f.writeBytes(s);            f.close();        } catch (IOException ie) {            ie.printStackTrace();        }    }    /**     * Logs a message to a file.     *     * @param s the message to log.     */    public synchronized void appendLog(String s) {        if (logfile == null) {            return;        }        if (active) {            if (lf == null) {                try {                    lf = new RandomAccessFile(logfile, "rw");                    lf.seek(lf.length());                } catch (IOException ie) {                    System.err.println("APPENDLOG ERROR #1");                    //ie.printStackTrace();                     return;                }            }            if (lf != null) {                try {                    lf.writeBytes(s);                } catch (IOException ie) {                    System.err.println("APPENDLOG ERROR #2");                }            }        }    }    /**     * Read a line of text from stdin.     *     * @return a line of text from stdin     */    public static String readLine() {        StringBuffer s = new StringBuffer();        try {            char c = 0;            while (c != '\n') {                c = (char) System.in.read();                if (c != '\n') {                    s.append(c);                }            }        } catch (IOException e) {            e.printStackTrace();        }        return s.toString();    }    public static double round(double f, int precision) {        if (Double.isNaN(f)) {            return f;        }        double n = 1;        for (int i = 0; i < precision; i++) {            n *= 10;        }        return java.lang.Math.round(f * n) / n;    }    public static String pad(String s, int size) {        if (s.length() < size) {            return pad(s + " ", size);        }        return s;    }    public void finalize() {        try {            lf.close();            lf = null;        } catch (IOException ie) {            System.err.println("FINALIZE ERROR");            //ie.printStackTrace();         }    }    /**     * Load the contents of a text file into a String     *     * @param fname the file name     * @return the contents of the file     */    public static String loadFile(String fname) {        StringBuffer sb = new StringBuffer();        try {            File file = new File(fname);            InputStream is = new BufferedInputStream(new FileInputStream(file));            int b = -1;            while ((b = is.read()) != -1) {                sb.append((char) b);            }            is.close();        } catch (IOException e) {            return null;        }        return sb.toString();    }    /**     * Attempts to execute the command.     *     * @param cmnd the command to execute     * @return null if unsuccessful, or the output of the command     */    public static String loadExec(String cmnd) {        StringBuffer sb = new StringBuffer();        try {            Runtime rt = java.lang.Runtime.getRuntime();            Process p = rt.exec(cmnd);            InputStream is = new BufferedInputStream(p.getInputStream());            p.waitFor();            int b = -1;            while ((b = is.read()) != -1) {                sb.append((char) b);            }        } catch (InterruptedException ie) {            return null;        } catch (IOException e) {            return null;        }        return sb.toString();    }    /**     * Prompt the user for a string.     *     * @param the text prompt     * @return what the user typed.     */    public String prompt(String s) {        reportb(s);        String r = readString();        if (r != null && r.length() > 0) {            return r;        } else {            return prompt(s);        }    }    /**     * Return the next line typed by the user.     *     * @return what the user typed.     */    public static String readString() {        String aString;        System.out.flush(); // Make sure all output is flushed        try {            aString = reader.readLine();        } catch (Exception e) {            return null;        }        return aString;    }    /**     * wait for the user to type enter.     */    public static void pause() {        try {            reader.readLine();        } catch (Exception e) {        }        //Keyboard.in.pause();    }    public String format(String s) {        return s.toLowerCase().trim();    }    public static boolean fileExists(String s) {        File f = new File(s);        return f.exists();    }}